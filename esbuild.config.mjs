import builtins from 'builtin-modules';
import * as dotenv from 'dotenv';
import esbuild from "esbuild";
import { copy } from 'esbuild-plugin-copy';
import watPlugin from 'esbuild-plugin-wat';
import fs from 'fs';
import path from 'path';
import process from "process";

dotenv.config()

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const demo = (process.argv[2] === 'demo');
const prod = (process.argv[2] === 'production');
const prev = (process.argv[2] === 'preview');
const buildv = prod || prev


import findCacheDir from 'find-cache-dir';

function inlineWorkerPlugin(extraConfig) {
  return {
    name: 'esbuild-plugin-inline-worker',

    setup(build) {
      build.onLoad(
        {filter: /\.worker\.(js|jsx|ts|tsx)$/},
        async ({path: workerPath}) => {
          // let workerCode = await fs.promises.readFile(workerPath, {
          //   encoding: 'utf-8',
          // });
          const workerLookup = {
            "indexer.worker.ts": "Superstate Indexer",
            "runner.worker.ts": "Superstate Runner",
            "search.worker.ts": "Superstate Search"
          }
          const workerName = workerPath.split('/').pop();
          

          let workerCode = await buildWorker(workerPath, extraConfig);
          return {
            contents: `import inlineWorker from '__inline-worker'
export default function Worker() {
  return inlineWorker(${JSON.stringify(workerCode)}, ${ JSON.stringify({name: workerLookup[workerName]})});
}
`,
            loader: 'js',
          };
        }
      );
      

      const inlineWorkerFunctionCode = `
export default function inlineWorker(scriptText, name) {
  let blob = new Blob([scriptText], {type: 'text/javascript'});
  let url = URL.createObjectURL(blob);
  let worker = new Worker(url, name);
  URL.revokeObjectURL(url);
  return worker;
}
`;

      build.onResolve({filter: /^__inline-worker$/}, ({path}) => {
        return {path, namespace: 'inline-worker'};
      });
      build.onLoad({filter: /.*/, namespace: 'inline-worker'}, () => {
        return {contents: inlineWorkerFunctionCode, loader: 'js'};
      });
    },
  };
}



let cacheDir = findCacheDir({
  name: 'esbuild-plugin-inline-worker',
  create: true,
});

async function buildWorker(workerPath, extraConfig) {
  let scriptNameParts = path.basename(workerPath).split('.');
  scriptNameParts.pop();
  scriptNameParts.push('js');
  let scriptName = scriptNameParts.join('.');
  let bundlePath = path.resolve(cacheDir, scriptName);

  if (extraConfig) {
    delete extraConfig.entryPoints;
    delete extraConfig.outfile;
    delete extraConfig.outdir;
    delete extraConfig.workerName;
  }

  
  await esbuild.build({
    entryPoints: [workerPath],
    bundle: true,
    minify: true,
    outfile: bundlePath,
		define: {
			process: 'process',
		},
    target: 'es2020',
    format: 'cjs',
    ...extraConfig,
  });

  return fs.promises.readFile(bundlePath, {encoding: 'utf-8'});
}



let renamePlugin = {
    name: 'rename-styles',
    setup(build) {
        build.onEnd(() => {
            const { outfile } = build.initialOptions;
            const outcss = outfile.replace(/\.js$/, '.css');
            const fixcss = outfile.replace(/main\.js$/, 'styles.css');
            if (fs.existsSync(outcss)) {
                console.log('Renaming', outcss, 'to', fixcss);
                fs.renameSync(outcss, fixcss);
            }
        });
    },
};


const outputDir = prev ? process.env.prevDir : prod ? process.env.buildDir : demo ? process.env.demoDir : process.env.devDir
esbuild.build({
	banner: {
		js: banner,
	},
	entryPoints: ['main.ts'],
	bundle: true,
	external: [
		'obsidian',
		'electron',
    // '@codemirror/autocomplete',
		'@codemirror/collab',
		'@codemirror/commands',
		// '@codemirror/language',
		'@codemirror/lint',
		'@codemirror/search',
		'@codemirror/state',
		'@codemirror/view',
		...builtins],
	format: 'cjs',
  loader: {
    '.ttf': 'base64', 
  },
	watch: !buildv,
	target: 'es2020',
	logLevel: "info",
	sourcemap: buildv ? false : 'inline',
	treeShaking: true,
  minify: true,
	outfile: outputDir+'/main.js',
  define: { 'process.env.NODE_ENV': prod ? '"production"' : '"development"' },
	plugins: [renamePlugin, 
		// preactCompatPlugin,
		inlineWorkerPlugin(),
		watPlugin(),
		...(buildv ? [copy({
			resolveFrom: 'cwd',
			assets: {
			  from: 'manifest.json',
			  to: outputDir+'/manifest.json',
			},
		  })] : []),
	],
}).catch(() => process.exit(1));

